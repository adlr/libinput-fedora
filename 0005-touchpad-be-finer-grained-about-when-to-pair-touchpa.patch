From f1a89760aa814787f0e1df43658b95bf88195592 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Fri, 22 May 2015 16:07:10 +1000
Subject: [PATCH libinput 05/10] touchpad: be finer-grained about when to pair
 touchpads/keyboard for DWT

Check a couple of easy yes/no definitives that cover most Lenovo laptops,
and avoid false positives on Wacoms.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Tested-by: Benjamin Tissoires <benjamin.tissoires@gmail.com>
---
 src/evdev-mt-touchpad.c | 54 +++++++++++++++++++++++++++++++++++--------------
 src/evdev-mt-touchpad.h |  2 --
 src/libinput-util.h     |  3 +++
 test/device.c           |  2 +-
 test/touchpad.c         |  2 +-
 5 files changed, 44 insertions(+), 19 deletions(-)

diff --git a/src/evdev-mt-touchpad.c b/src/evdev-mt-touchpad.c
index 5a05129..3a0985d 100644
--- a/src/evdev-mt-touchpad.c
+++ b/src/evdev-mt-touchpad.c
@@ -938,15 +938,43 @@ tp_keyboard_event(uint64_t time, struct libinput_event *event, void *data)
 			   time + timeout);
 }
 
+static bool
+tp_want_dwt(struct evdev_device *touchpad,
+	    struct evdev_device *keyboard)
+{
+	unsigned int bus_tp = libevdev_get_id_bustype(touchpad->evdev),
+		     bus_kbd = libevdev_get_id_bustype(keyboard->evdev);
+
+	if (bus_tp == BUS_BLUETOOTH || bus_kbd == BUS_BLUETOOTH)
+		return false;
+
+	/* evemu will set the right bus type */
+	if (bus_tp == BUS_VIRTUAL || bus_kbd == BUS_VIRTUAL)
+		return false;
+
+	/* If the touchpad is on serio, the keyboard is too, so ignore any
+	   other devices */
+	if (bus_tp == BUS_I8042 && bus_kbd != bus_tp)
+		return false;
+
+	/* Wacom makes touchpads, but not internal ones */
+	if (libevdev_get_id_vendor(touchpad->evdev) == VENDOR_ID_WACOM)
+		return false;
+
+	/* everything else we don't really know, so we have to assume
+	   they go together */
+
+	return true;
+}
+
 static void
 tp_device_added(struct evdev_device *device,
 		struct evdev_device *added_device)
 {
 	struct tp_dispatch *tp = (struct tp_dispatch*)device->dispatch;
 	unsigned int bus_tp = libevdev_get_id_bustype(device->evdev),
-		     bus_trp = libevdev_get_id_bustype(added_device->evdev),
-		     bus_kbd = libevdev_get_id_bustype(added_device->evdev);
-	bool tp_is_internal, trp_is_internal, kbd_is_internal;
+		     bus_trp = libevdev_get_id_bustype(added_device->evdev);
+	bool tp_is_internal, trp_is_internal;
 
 	tp_is_internal = bus_tp != BUS_USB && bus_tp != BUS_BLUETOOTH;
 	trp_is_internal = bus_trp != BUS_USB && bus_trp != BUS_BLUETOOTH;
@@ -962,18 +990,14 @@ tp_device_added(struct evdev_device *device,
 					tp_trackpoint_event, tp);
 	}
 
-	if (added_device->tags & EVDEV_TAG_KEYBOARD) {
-		/* FIXME: detect external keyboard better */
-		kbd_is_internal = bus_tp != BUS_BLUETOOTH &&
-				  bus_kbd == bus_tp;
-		if (tp_is_internal && kbd_is_internal &&
-		    tp->dwt.keyboard == NULL) {
-			libinput_device_add_event_listener(&added_device->base,
-						&tp->dwt.keyboard_listener,
-						tp_keyboard_event, tp);
-			tp->dwt.keyboard = added_device;
-			tp->dwt.keyboard_active = false;
-		}
+	if (added_device->tags & EVDEV_TAG_KEYBOARD &&
+	    tp->dwt.keyboard == NULL &&
+	    tp_want_dwt(device, added_device)) {
+		libinput_device_add_event_listener(&added_device->base,
+					&tp->dwt.keyboard_listener,
+					tp_keyboard_event, tp);
+		tp->dwt.keyboard = added_device;
+		tp->dwt.keyboard_active = false;
 	}
 
 	if (tp->sendevents.current_mode !=
diff --git a/src/evdev-mt-touchpad.h b/src/evdev-mt-touchpad.h
index f8c837d..db877c7 100644
--- a/src/evdev-mt-touchpad.h
+++ b/src/evdev-mt-touchpad.h
@@ -32,8 +32,6 @@
 #define TOUCHPAD_HISTORY_LENGTH 4
 #define TOUCHPAD_MIN_SAMPLES 4
 
-#define VENDOR_ID_APPLE 0x5ac
-
 /* Convert mm to a distance normalized to DEFAULT_MOUSE_DPI */
 #define TP_MM_TO_DPI_NORMALIZED(mm) (DEFAULT_MOUSE_DPI/25.4 * mm)
 
diff --git a/src/libinput-util.h b/src/libinput-util.h
index 74226b9..89f5230 100644
--- a/src/libinput-util.h
+++ b/src/libinput-util.h
@@ -30,6 +30,9 @@
 
 #include "libinput.h"
 
+#define VENDOR_ID_APPLE 0x5ac
+#define VENDOR_ID_WACOM 0x56a
+
 void
 set_logging_enabled(int enabled);
 
diff --git a/test/device.c b/test/device.c
index 1c277ba..0e494c4 100644
--- a/test/device.c
+++ b/test/device.c
@@ -69,7 +69,7 @@ START_TEST(device_sendevents_config_touchpad)
 	expected = LIBINPUT_CONFIG_SEND_EVENTS_DISABLED;
 
 	/* The wacom devices in the test suite are external */
-	if (libevdev_get_id_vendor(dev->evdev) != 0x56a) /* wacom */
+	if (libevdev_get_id_vendor(dev->evdev) != VENDOR_ID_WACOM)
 		expected |=
 			LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE;
 
diff --git a/test/touchpad.c b/test/touchpad.c
index 576b2bd..2624dda 100644
--- a/test/touchpad.c
+++ b/test/touchpad.c
@@ -2951,7 +2951,7 @@ touchpad_has_palm_detect_size(struct litest_device *dev)
 	double width, height;
 	int rc;
 
-	if (libinput_device_get_id_vendor(dev->libinput_device) == 0x5ac) /* Apple */
+	if (libinput_device_get_id_vendor(dev->libinput_device) == ID_VENDOR_APPLE)
 		return 1;
 
 	rc = libinput_device_get_size(dev->libinput_device, &width, &height);
-- 
2.4.1

